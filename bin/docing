#!/usr/bin/env node

// #DocIng
//
// Auto generate documents for your codes. Any language and any format can be covered by DocIng.
//
// **Author**: DanielZhu(enterzhu@gmail.com)
// **Datae**: 2014/07/19
//
// Copyright 2014. Zhu Meng Dan

var fse = require('fs-extra');
var path = require('path');
var sys=require('sys');
var program = require('commander');
var split = require('../libs/split');
var output = require('../libs/output');
var lang = require('../libs/lang');

/**
 * Module dependencies.
 */

program
  .version('0.1.6')
  .usage('[options] <files or dirs>')
  .option('-o, --output [path]', 'All the docs will put into this directory, the current path is the default output.', '.')
  .option('-l, --log', '0.1.6')
  .parse(process.argv);

// console.log(' args: %j', program.args);

var inputPath = program.args[0].replace(/\\/g, '/');
// Real output path
var resultPath = '';
var fileTree = null;
var fileQueue = [];

// Main entry point
var startDocing = function () {

  sys.debug("Starting ...");

  analyzeBasePath();
  fileTree = analyzeFileStructure(inputPath);

  praseAndFormatFiles();

  copyResources(resultPath);

  sys.debug("The End ...");
  fse.writeFileSync('C:/staydan.com/rabbit/tree.json', JSON.stringify(fileTree), {encoding: 'utf8'});
};

var praseAndFormatFiles = function () {
  while (fileQueue.length > 0) {
    var file = fileQueue.splice(0, 1)[0];
    translateFile(file);
  }
};

// Create base path
var analyzeBasePath = function () {
  resultPath = program.output;
  if (program.output === '.') {
    var inputPathCopy = inputPath;
    console.log('inputPathCopy1: ' + inputPathCopy);
    while (inputPathCopy.substr(-1) === '/') {
      inputPathCopy = inputPathCopy.substr(1, inputPathCopy.lastIndexOf('/'));
    }
    console.log('inputPathCopy2: ' + inputPathCopy);
    resultPath += inputPathCopy.substr(inputPathCopy.lastIndexOf('/'));
  }

  resultPath += '/Docing';
};

// Read the directory 'Docing/js/'
var analyzeFileStructure = function (filePath, nodeParent) {
  console.log('filePath: ' + filePath);

  var files = fse.readdirSync(filePath);
  console.log(JSON.stringify(files));

  var nodeRoot = {};
  var filePaths = filePath.split('/');
  var folderName = filePaths[filePaths.length - 1];

  if (nodeParent !== undefined) {
    nodeRoot = nodeParent;
  } else {
    nodeRoot = createNode(folderName, filePath, true);
  }

  if (files !== null && files.length > 0) {
    for (var i = 0; i < files.length; i++) {
      var file = filePath + '/' + files[i];
      var stats = fse.statSync(file);
      if (stats !== null) {
        var node = null;

        if (stats.isFile()) {
          node = createNode(files[i], file, false);
          // file: the real file path
          fileQueue.push(file);
          // If nodeParent passed and not null, all the node created here should be push into it.
          // if (nodeRoot !== null) {
          nodeRoot.children.push(node);
          // }
        } else if (stats.isDirectory()) {
          node = createNode(files[i], file, true);
          nodeRoot.children.push(analyzeFileStructure(file, node));
        }
      }
    }
  } else {
    // if (nodeParent !== null) {
    //   nodeRoot.children.push(createNode(filePaths[filePaths.length - 1], filePath));
    // }
  }

  return nodeRoot;
}

// Expected format of the node (there are no required fields)
// {
//   id          : "string" // will be autogenerated if omitted
//   text        : "string" // node text
//   icon        : "string" // string for custom
//   state       : {
//     opened    : boolean  // is the node open
//     disabled  : boolean  // is the node disabled
//     selected  : boolean  // is the node selected
//   },
//   children    : []  // array of strings or objects
//   li_attr     : {}  // attributes for the generated LI node
//   a_attr      : {}  // attributes for the generated A node
// }
var translateFile = function (filePath) {
  var extName = path.extname(filePath);
  var fileName = path.basename(filePath, extName);
  var readStream = null;
  var outputList = [];

  console.log('Translating... =>' + filePath);
  var stats = fse.statSync(filePath);
  if (stats.isFile()) {
    var langConfig = lang.loadLangConfigByExtName(extName);
    if (langConfig.error !== undefined) {
      console.log(langConfig.error);
    } else {
      var fileData = fse.readFileSync(filePath, 'utf8');
      // console.log('got %d bytes of data', fileData.length);

      // Add the end symbol to each file.
      fileData += '\n';
      outputList = split.splitOutSrc(fileData, langConfig);

      output.renderHtml(outputList, langConfig, resultPath, filePath.substr(inputPath.length), fileTree);
    }
  }
};

var copyResources = function (docPath) {
  //copies directory, even if it has subdirectories or files
  fse.copySync(path.join(__dirname, '../resources'), docPath + '/resources'); 

  // var cssFile = filePath + 'resources/docing.css';
  // var resourceExist = fse.existsSync(filePath + 'resources');
  // if (!resourceExist) {
  //   fse.mkdirSync(filePath + 'resources', '0777');
  // }
  // fse.open(cssFile , 'w+', '0777', function(err, fd) {
  //   fse.closeSync(fd);
  //   var readStream = fse.createReadStream('./resources/docing.css', {encoding: 'utf8', autoClose: true});

  //   readStream.on('data', function(chunk) {
  //     writeToFile(cssFile, chunk);
  //   });
  // });
};

var createNode = function (text, path, folderFlag) {
  var node = {};
  var nodeStatus = {};

  // nodeStatus['opened'] = false;
  // nodeStatus['disabled'] = false;
  // nodeStatus['selected'] = false;

  // node['id'] = 0;
  node['text'] = text;
  node['icon'] = (folderFlag ? 'jstree-default-small jstree-folder' : 'jstree-default-small jstree-file');
  node['children'] = [];
  // node['li_attr'] = [];
  // node['a_attr'] = [];
  // node['a_attr']['href'] = path;
  // node['state'] = nodeStatus;

  return node;
};

startDocing();